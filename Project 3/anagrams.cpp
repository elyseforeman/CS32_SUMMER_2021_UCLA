//
// ELYSE FOREMAN
// PROJECT 3
// anagrams.cpp

#include <iostream>
#include <fstream>
#include <istream>
#include <cstring>
using namespace std;

const int MAXRESULTS   = 20;        // Max matches that can be found
const int MAXDICTWORDS = 25000;     // Max words that can be read in

// ///////////////////////////////////
// FUNCTION 1 ////////////////////////
// ///////////////////////////////////

// Puts each string in dictfile into the array dict. Returns the number of words
// read into dict. This number should not be larger than MAXDICTWORDS since that is
// the size of the array

// forward declarations
int fillDictionary(int i, istream &dictfile, string dict[]);

int makeDictionary(istream &dictfile, string dict[])
{
    return fillDictionary(0, dictfile, dict);
}
// fill and count words added to dictionary helper funciton
int fillDictionary(int i, istream &dictfile, string dict[])
{
    if (i >= MAXDICTWORDS)
        return MAXDICTWORDS;
    string line;
    if (getline(dictfile, line))
        dict[0] = line;
    else
        return i;
    return fillDictionary(i+1, dictfile, dict+1);
}

// ///////////////////////////////////
// FUNCTION 2 ////////////////////////
// ///////////////////////////////////

//Puts all the possibilities of word which are found in dict into results. Returns the number of matched words found. This number should not be larger than MAXRESULTS since that is the size of the array. The size is the number of words inside the dict array.

// forward declarations
int permutation(string prefix, string rest, const string dict[], int dictSize, string results[]);
int generatePermutations(int i, int wordSize, string prefix, string rest, const string dict[], int dictSize, string results[]);
bool compareDict(string permutation, const string dict[], int dictSize, string results[]);
bool compareResults(int i, string permutation, string results[]);
int loopResults(int i, string results[]);

int shuffleChars(string word, const string dict[], int size, string results[])
{
    return permutation("", word, dict, size, results);
}

int permutation(string prefix, string rest, const string dict[], int dictSize, string results[])
{
    int wordSize = rest.size();
    if (wordSize == 0)
    {
        // if the permutation generated by loop() is not already in results, check if it is in dict
        // if the permutation is present in dict, add it to results and return 1 to indicate that results size has increased by 1. If not, return 0
        if (!compareResults(0, prefix, results) && compareDict(prefix, dict, dictSize, results))
            return 1;
        return 0;
    }
    else
        return generatePermutations(0, wordSize, prefix, rest, dict, dictSize, results);
}
// generates permutations
int generatePermutations(int i, int wordSize, string prefix, string rest, const string dict[], int dictSize, string results[])
{
    if (i >= wordSize)
        return 0;
    char ch = rest[i];                          // obtain a character from rest
    string left = rest.substr(0,i);             // remove this character from rest
    string right = rest.substr(i+1, wordSize);
    // Use recursion to generate permutations with updated prefix and rest
    return permutation(prefix+ch, left+right, dict, dictSize, results)+
    generatePermutations(i+1, wordSize, prefix, rest, dict, dictSize, results);
}
// returns true if the permutation is present in dict[]
bool compareDict(string permutation, const string dict[], int dictSize, string results[])
{
    if (dictSize == 0)
        return false;
    
    // if the dictionary contains a permutation found through permutation(), add this permutation to results[]
    if (*dict == permutation)
    {
        // set k to the current number of results
        int k = loopResults(0, results);
        // set the kth element of results equal to permutation
        results[k] = permutation;
        return true;
    }
    return compareDict(permutation, dict+1, dictSize-1, results);
}
// returns true if the permutation is present in results[]
bool compareResults(int i, string permutation, string results[])
{
    if (results[i] == "")
        return false;
    if (results[i] == permutation)
        return true;
    return compareResults(i+1, permutation, results);
}
// returns the position of the next empty slot in results
int loopResults(int i, string results[])
{
    if (results[i] == "")
        return 0;
    int k = loopResults(i+1, results);
    ++k;
    return k;
}

// ///////////////////////////////////
// FUNCTION 3 ////////////////////////
// ///////////////////////////////////

// Displays size number of strings from results. The results can be printed in any order.

// forward declarations
int loopDisplay(int i, int size, const string results[]);

void revealOutcomes(const string results[], int size)
{
    // cout no matches found if loop display does not print any words
    if(loopDisplay(0, size, results)==0)
        cout << "No matches found" << endl;
}
// returns an int to indicate whether or not results was empty
int loopDisplay(int i, int size, const string results[])
{
    if (i >= size)
        return 0;
    cout << "Matching Word: " << results[i] << endl;
    int k = loopDisplay(i+1, size, results);
    ++k;
    return k;
}

int main()
{
    string dict[MAXDICTWORDS];
    string results[MAXRESULTS];
    string word;
    cout << "Please enter a string for an anagram: ";
    cin >> word;
    
    ifstream dictfile("dictfile.txt");
    int dictSize = makeDictionary(dictfile, dict);
    int resultsSize = shuffleChars(word, dict, dictSize, results);
    revealOutcomes(results, resultsSize);
    return 0;
}
